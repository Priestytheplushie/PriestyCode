name: PriestyBot Auto-Review & CodeQL

on:
  push:
    branches:
      - main
  pull_request:
    types: [review_requested, synchronize]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  checks: write
  security-events: write

jobs:
  lint-and-test:
    name: Lint & Test
    if: |
      (github.event.action == 'review_requested' && github.event.requested_reviewer.login == 'PriestyBot') ||
      (github.event.action == 'synchronize' && contains(github.event.pull_request.labels.*.name, 'priestybot-review'))
    runs-on: ubuntu-latest
    outputs:
      flake8_outcome: ${{ steps.flake8.conclusion }}
      black_outcome: ${{ steps.black.conclusion }}
      isort_outcome: ${{ steps.isort.conclusion }}
      bandit_outcome: ${{ steps.bandit.conclusion }}
      mypy_outcome: ${{ steps.mypy.conclusion }}
      app_test_outcome: ${{ steps.app_test.conclusion }}
    steps:
      - name: Add 'priestybot-review' Label
        if: github.event.action == 'review_requested'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['priestybot-review']
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `Hey @${context.payload.pull_request.user.login}! üëã Thanks for the review request. I'll get started right away.\n\nP.S. I've added the \`priestybot-review\` label. I'll keep re-reviewing any new changes you push. If you want me to stop, just remove the label!`
            });
      - name: üí¨ Acknowledging new changes
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `Just noticed you pushed new changes! Taking another look... üßê`
            });

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install flake8 black isort mypy bandit # reviewdog is installed by its action now

      - name: Create linter-reports directory
        run: mkdir -p linter-reports

      - name: üíß Run Linter (flake8)
        id: flake8
        continue-on-error: true
        run: |
          flake8 src > flake8_raw_output.txt || true 
          if [ -s flake8_raw_output.txt ]; then
            # Using -f=flake8 and pipe. If BrokenPipeError persists, means reviewdog's parser isn't happy.
            cat flake8_raw_output.txt | reviewdog -f=flake8 -reporter=rdjson -filter-mode=nofilter > linter-reports/flake8.rdjson || echo "{ \"diagnostics\": [] }" > linter-reports/flake8.rdjson
          else
            echo "{ \"diagnostics\": [] }" > linter-reports/flake8.rdjson
          fi

      - name: üíÖ Run Format Check (black)
        id: black
        continue-on-error: true
        run: |
          # Black's output for --check primarily says "would reformat", lacks precise line numbers needed for inline comments.
          # Aggregating to summary is more practical for black.
          black --check src > black_raw_output.txt 2>&1 || true
          if [ -s black_raw_output.txt ]; then
            cat black_raw_output.txt | reviewdog -f=black -reporter=rdjson -filter-mode=nofilter > linter-reports/black.rdjson || echo "{ \"diagnostics\": [] }" > linter-reports/black.rdjson
          else
            echo "{ \"diagnostics\": [] }" > linter-reports/black.rdjson
          fi
      
      - name: sorted? Run Import Sort Check (isort)
        id: isort
        continue-on-error: true
        run: |
          # Similar to black, isort --check output often lacks precise line numbers.
          # Aggregating to summary is more practical.
          isort --check src > isort_raw_output.txt || true
          if [ -s isort_raw_output.txt ]; then
            cat isort_raw_output.txt | reviewdog -f=isort -reporter=rdjson -filter-mode=nofilter > linter-reports/isort.rdjson || echo "{ \"diagnostics\": [] }" > linter-reports/isort.rdjson
          else
            echo "{ \"diagnostics\": [] }" > linter-reports/isort.rdjson
          fi
      
      - name: üîí Run Security Check (bandit)
        id: bandit
        continue-on-error: true
        run: |
          bandit -r src -f json > bandit_raw_output.json || true

          cat << 'EOF' > convert_bandit_to_rdjson.py
          import json
          import sys
          import os

          def convert_bandit_to_rdjson(bandit_report_path, rdjson_output_path):
              diagnostics = []
              try:
                  if not os.path.exists(bandit_report_path) or os.stat(bandit_report_path).st_size == 0:
                      print(f"Bandit report file {bandit_report_path} is empty or missing. Creating empty rdjson.")
                      with open(rdjson_output_path, 'w') as f:
                          json.dump({"source": {"name": "bandit"}, "diagnostics": []}, f, indent=2)
                      return

                  with open(bandit_report_path, 'r') as f:
                      bandit_data = json.load(f)
              except (FileNotFoundError, json.JSONDecodeError) as e:
                  print(f"Error loading/parsing Bandit report: {e}. Creating empty rdjson.")
                  with open(rdjson_output_path, 'w') as f:
                      json.dump({"source": {"name": "bandit"}, "diagnostics": []}, f, indent=2)
                  return

              for result in bandit_data.get('results', []):
                  diagnostics.append({
                      "message": f"[{result['test_id']}] {result['issue_text']} (Confidence: {result['issue_confidence']}, Severity: {result['issue_severity']})",
                      "location": {
                          "path": result['filename'],
                          "range": {
                              "start": {"line": result['line_number']},
                              "end": {"line": result['end_line_number'] if 'end_line_number' in result else result['line_number']}
                          }
                      },
                      "level": "error" if result['issue_severity'] == 'HIGH' else ("warning" if result['issue_severity'] == 'MEDIUM' else "info"),
                      "code": {"value": result['test_name']}
                  })
              
              rdjson_report = {
                  "source": {"name": "bandit"},
                  "diagnostics": diagnostics
              }

              with open(rdjson_output_path, 'w') as f:
                  json.dump(rdjson_report, f, indent=2)

          if __name__ == "__main__":
              convert_bandit_to_rdjson(sys.argv[1], sys.argv[2])
          EOF
          python convert_bandit_to_rdjson.py bandit_raw_output.json linter-reports/bandit.rdjson

      - name: üßê Run Type Check (mypy)
        id: mypy
        continue-on-error: true
        run: |
          mypy src > mypy_raw_output.txt || true

          cat << 'EOF' > convert_mypy_to_rdjson.py
          import json
          import sys
          import re
          import os

          def convert_mypy_to_rdjson(mypy_report_path, rdjson_output_path):
              diagnostics = []
              mypy_pattern = re.compile(r"^(.*?):(\d+)(?::(\d+))?: (.*?): (.*)$")

              try:
                  if not os.path.exists(mypy_report_path) or os.stat(mypy_report_path).st_size == 0:
                      print(f"Mypy report file {mypy_report_path} is empty or missing. Creating empty rdjson.")
                      with open(rdjson_output_path, 'w') as f:
                          json.dump({"source": {"name": "mypy"}, "diagnostics": []}, f, indent=2)
                      return

                  with open(mypy_report_path, 'r') as f:
                      for line in f:
                          match = mypy_pattern.match(line.strip())
                          if match:
                              file_path = match.group(1)
                              line_num = int(match.group(2))
                              col_num = int(match.group(3)) if match.group(3) else 0
                              level_str = match.group(4).lower()
                              message = match.group(5)

                              level = "info" # Default
                              if "error" in level_str:
                                  level = "error"
                              elif "warning" in level_str:
                                  level = "warning"
                              elif "note" in level_str:
                                  level = "info"

                              diagnostics.append({
                                  "message": message,
                                  "location": {
                                      "path": file_path,
                                      "range": {
                                          "start": {"line": line_num, "column": col_num},
                                          "end": {"line": line_num, "column": col_num}
                                      }
                                  },
                                  "level": level,
                                  "code": {"value": level_str}
                              })
                          else:
                              print(f"Skipping unparsable mypy line: {line.strip()}")

              except Exception as e:
                  print(f"Error processing Mypy report: {e}. Creating empty rdjson.")
                  with open(rdjson_output_path, 'w') as f:
                      json.dump({"source": {"name": "mypy"}, "diagnostics": []}, f, indent=2)
                  return

              rdjson_report = {
                  "source": {"name": "mypy"},
                  "diagnostics": diagnostics
              }

              with open(rdjson_output_path, 'w') as f:
                  json.dump(rdjson_report, f, indent=2)

          if __name__ == "__main__":
              convert_mypy_to_rdjson(sys.argv[1], sys.argv[2])
          EOF
          python convert_mypy_to_rdjson.py mypy_raw_output.txt linter-reports/mypy.rdjson

      - name: üß™ Run Tkinter App Test
        id: app_test
        continue-on-error: true
        run: |
          echo "Starting the Tkinter app in a virtual display..."
          if xvfb-run timeout 10s python -m src.main; then
            echo "App test result: PASSED (exited cleanly before timeout)"
            exit 0
          else
            exit_code=$?
            if [ $exit_code -eq 124 ]; then
              echo "App test result: PASSED (ran for 10s and timed out, which implies no crash)."
              exit 0
            else
              echo "App test result: FAILED (app crashed with exit code $exit_code)."
              exit $exit_code
            fi
          fi
      
      - name: Upload Linter Reports
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: linter-reports
          path: linter-reports/*.rdjson
          retention-days: 1

  codeql:
    name: CodeQL Analysis
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event.action == 'review_requested' && github.event.requested_reviewer.login == 'PriestyBot') ||
      (github.event.action == 'synchronize' && contains(github.event.pull_request.labels.*.name, 'priestybot-review'))
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
    outputs:
      analyze_outcome: ${{ steps.analyze.outcome }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.ref }}
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python
          config-file: ./.github/codeql/codeql-config.yml
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
      - name: Perform CodeQL Analysis
        id: analyze
        uses: github/codeql-action/analyze@v3

  final-review:
    name: Post Final Review
    if: always() && needs.lint-and-test.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [lint-and-test, codeql]
    steps:
      - name: Download Linter Reports
        uses: actions/download-artifact@v4
        with:
          name: linter-reports
          path: linter-reports

      - name: üìù Post Final Review Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const commentsToPost = []; // This will hold all comments: inline or file-level
            const summaryDiagnostics = {}; // For summary aggregation as a last resort

            const reportDir = './linter-reports';
            try {
              const files = fs.readdirSync(reportDir);
              for (const file of files) {
                if (file.endsWith('.rdjson')) {
                  const content = fs.readFileSync(path.join(reportDir, file), 'utf8');
                  if (!content.trim()) { 
                      console.log(`File ${file} is empty or contains only whitespace, skipping.`);
                      continue;
                  }
                  let report;
                  try {
                      report = JSON.parse(content);
                  } catch (e) {
                      console.error(`Failed to parse JSON from ${file}: ${e.message}`);
                      continue;
                  }
                  
                  const sourceName = report.source?.name || path.basename(file, '.rdjson'); 
                  summaryDiagnostics[sourceName] = summaryDiagnostics[sourceName] || []; 

                  if (!report.diagnostics || report.diagnostics.length === 0) {
                      console.log(`No diagnostics found in ${file}.`);
                      continue;
                  }

                  for (const diag of report.diagnostics) {
                    const location = diag.location || diag.primaryLocation; 
                    const filePath = location?.path;
                    const startLine = location?.range?.start?.line || location?.span?.start?.line; 
                    
                    if (filePath && typeof startLine === 'number' && startLine > 0) { 
                      // Attempt inline comment first
                      commentsToPost.push({
                          path: filePath,
                          line: startLine,
                          body: `**[${sourceName}]**: ${diag.message}`
                      });
                    } else if (filePath) { 
                      // If no valid line, but has a path, add as file-level comment
                      commentsToPost.push({
                          path: filePath,
                          body: `**[${sourceName}]**: ${diag.message} (General issue in file)`
                      });
                      summaryDiagnostics[sourceName].push(`${diag.message} (File: \`${filePath}\`)`);
                    } else {
                        // If no path, add to summary as last resort
                        summaryDiagnostics[sourceName].push(`[${sourceName}] (General Issue): ${diag.message}`);
                        console.log(`Diagnostic from ${sourceName} only added to summary due to missing path: ${JSON.stringify(diag)}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.log("Could not process linter reports, likely none were generated or directory issues:", error.message);
            }

            const pr_author = context.payload.pull_request.user.login;
            let review_body = `Hi @${pr_author}, I've finished my review!\n\n`;
            let event = 'APPROVE';
            let is_perfect_run = true; 

            const outcomes = {
              flake8: { conclusion: `${{ needs.lint-and-test.outputs.flake8_outcome }}`, title: `üé® Linting Issues (\`flake8\`)` },
              black: { conclusion: `${{ needs.lint-and-test.outputs.black_outcome }}`, title: `üé® Formatting & Style (\`black\`)` },
              isort: { conclusion: `${{ needs.lint-and-test.outputs.isort_outcome }}`, title: `üé® Import Order (\`isort\`)` },
              bandit: { conclusion: `${{ needs.lint-and-test.outputs.bandit_outcome }}`, title: `üö® Security Analysis (\`bandit\`)` }, 
              mypy: { conclusion: `${{ needs.lint-and-test.outputs.mypy_outcome }}`, title: `üö® Type Checking (\`mypy\`)` }, 
              app_test: { conclusion: `${{ needs.lint-and-test.outputs.app_test_outcome }}`, title: `üö® Application Test` }, 
              codeql: { conclusion: `${{ needs.codeql.outputs.analyze_outcome }}`, title: `üö® Advanced Security (\`CodeQL\`)` } 
            };

            const appTestPassed = outcomes.app_test.conclusion === 'success';
            const hasAnyLinterIssues = commentsToPost.length > 0 || Object.values(summaryDiagnostics).some(arr => arr.length > 0);
            const codeQLFailed = outcomes.codeql.conclusion === 'failure';
            const anyLinterStepFailed = ['flake8', 'black', 'isort', 'bandit', 'mypy'].some(linter => outcomes[linter].conclusion === 'failure');

            // --- Core Logic: Determine APPROVE vs. REQUEST_CHANGES ---

            if (!appTestPassed) {
                // If app test failed, always request changes.
                event = 'REQUEST_CHANGES';
                review_body += `**üö® Critical Issue: The Tkinter application failed to run for 10 seconds!**\n`;
                review_body += `Please ensure the \`src/main.py\` application starts correctly and remains stable for at least 10 seconds without crashing. This is a primary requirement for merging.\n\n`;
                
                // If the app test failed, any other failures also become important to mention.
                if (hasAnyLinterIssues || codeQLFailed || anyLinterStepFailed) {
                    review_body += `---\n\nAdditionally, I found other issues (these become blocking since the app test failed):\n\n`;
                    // List all specific linters/CodeQL that had issues or whose steps failed
                    if (anyLinterStepFailed) {
                        review_body += `* **Failed Linter/Check Steps:**\n`;
                        ['flake8', 'black', 'isort', 'bandit', 'mypy'].forEach(linter => {
                            if (outcomes[linter].conclusion === 'failure') {
                                review_body += `    - ${outcomes[linter].title} failed its check. See workflow logs.\n`;
                            }
                        });
                    }
                    if (codeQLFailed) {
                        review_body += `* **CodeQL Analysis:** Failed. Go to the 'Security' tab for details.\n`;
                    }
                    if (commentsToPost.length > 0) {
                         review_body += `* **Linter/Static Analysis Findings:** See comments on code or aggregated details below.\n`;
                    }
                }
                
                // Add aggregated diagnostics to the summary (even if app test failed)
                let aggregatedDetails = '';
                for (const linterName in summaryDiagnostics) {
                    if (summaryDiagnostics[linterName].length > 0) {
                        aggregatedDetails += `\n### ${outcomes[linterName]?.title || linterName} (Aggregated):\n`;
                        for (const msg of summaryDiagnostics[linterName]) {
                            aggregatedDetails += `- ${msg}\n`;
                        }
                    }
                }
                if (aggregatedDetails) {
                    review_body += `\n---\n\n## üìã Detailed Linter Findings (Aggregated):\n`;
                    review_body += aggregatedDetails;
                    review_body += `\n---\n`;
                }

                review_body += `\nPlease address these issues, especially the application test failure. Let me know if you have questions!`;
                is_perfect_run = false; 

            } else { // App Test PASSED üéâ
                review_body += `The Tkinter application passed its 10-second run test successfully! üéâ This PR is good to merge.\n\n`;
                
                if (hasAnyLinterIssues || codeQLFailed || anyLinterStepFailed) {
                    // App Test passed, so linters/CodeQL are advisory. Still APPROVE.
                    event = 'APPROVE'; 
                    review_body += `However, I've found some **advisory suggestions** to improve the code quality. These are not blockers for merging but are highly recommended:\n\n---\n\n`;
                    
                    if (anyLinterStepFailed) {
                        review_body += `* **Some Linter Steps Failed:** While not blocking, these indicate potential issues. Please investigate the workflow logs for more details.\n`;
                    }
                    if (codeQLFailed) {
                        review_body += `* **CodeQL Analysis:** Failed. Go to the 'Security' tab for detailed advice.\n`;
                    }
                    if (commentsToPost.length > 0) {
                        review_body += `* **Code Comments:** Please check the code for inline or file-level comments outlining specific suggestions.\n`;
                    } else {
                        review_body += `* **Aggregated Linter Findings:** No specific code comments were generated, but review the 'Detailed Linter Findings' section below for aggregated advice.\n`;
                    }
                    
                    // Add aggregated diagnostics to the summary
                    let aggregatedDetails = '';
                    for (const linterName in summaryDiagnostics) {
                        if (summaryDiagnostics[linterName].length > 0) {
                            aggregatedDetails += `\n### ${outcomes[linterName]?.title || linterName} (Aggregated):\n`;
                            for (const msg of summaryDiagnostics[linterName]) {
                                aggregatedDetails += `- ${msg}\n`;
                            }
                        }
                    }

                    if (aggregatedDetails) {
                        review_body += `\n---\n\n## üìã Detailed Linter Findings (Aggregated):\n`;
                        review_body += aggregatedDetails;
                        review_body += `\n---\n`;
                    }

                    review_body += `\nFeel free to merge this PR. Addressing these suggestions would be beneficial for code quality!`;
                    is_perfect_run = false; 
                } else {
                    // App test passed, AND no linter/CodeQL issues
                    review_body += `Everything looks perfectly clean! All checks passed, including the application test. Keep up the fantastic work! üëç`;
                    is_perfect_run = true;
                }
            }

            // Post the review
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: event,
              body: review_body,
              comments: commentsToPost 
            });
            
            // Remove label only if the entire run was "perfect"
            if (is_perfect_run) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: 'priestybot-review'
                });
              } catch (error) {
                console.log("Could not remove 'priestybot-review' label, it might not exist or already be removed.");
              }
            }