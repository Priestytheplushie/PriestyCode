name: PriestyBot Auto-Review

on:
  pull_request:
    types: [review_requested]

env:
  # Using a PAT to allow the bot to approve the PR
  APPROVER_TOKEN: ${{ secrets.APPROVER_TOKEN }}
  # Reviewdog needs a token with pull-request write permissions
  REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.APPROVER_TOKEN }}

permissions:
  contents: read
  pull-requests: write
  # FIX: 'checks: write' permission is required for the 'github-pr-check' reporter.
  checks: write

jobs:
  review:
    # Only run if the reviewer is the bot itself
    if: github.event.requested_reviewer.login == 'PriestyBot'
    runs-on: ubuntu-latest
    steps:
      - name: üí¨ Acknowledging the review request...
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.APPROVER_TOKEN }}
          script: |
            const pr_number = context.issue.number;
            const bot_name = "PriestyBot";
            const pr_author = context.payload.sender.login;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
            });
            const hasAlreadyCommented = comments.some(
              comment => comment.user.login === bot_name && comment.body.includes("Thanks for asking me to review")
            );

            if (!hasAlreadyCommented) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                // FIX: Use backticks (`) for template literals and access the sender from the script's context object.
                body: `Hey @${pr_author}! üëã Thanks for asking me to review. I'll take a look at the code now and get back to you shortly. üßê`
              });
            }

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          sudo apt-get update && sudo apt-get install -y xvfb

      - name: üíß Run Linter (flake8) on Changed Files
        id: lint
        # FIX: Allows workflow to continue even if linter finds issues.
        continue-on-error: true
        uses: reviewdog/action-flake8@v3
        with:
          filter_mode: "diff_context"
          # FIX: Fails the step if issues are found, so we can check its 'outcome'.
          fail_on_error: true
          # FIX: Use 'github-pr-check' to post inline comments on the code diff.
          reporter: github-pr-check
          level: warning

      - name: üíÖ Run Format Check (black) on Changed Files
        id: format_check
        # FIX: Same changes as the linter step for consistency.
        continue-on-error: true
        uses: reviewdog/action-black@v3
        with:
          filter_mode: "diff_context"
          fail_on_error: true
          reporter: github-pr-check
          level: warning
          black_args: "--check --diff src"
      
      - name: üß™ Run Tkinter App Test
        id: app_test
        # FIX: Restructured the script to correctly handle the 'timeout' exit code (124) as a success.
        # The default 'set -e' shell option was causing the step to fail immediately on exit code 124.
        run: |
          echo "Starting the Tkinter app in a virtual display..."
          if xvfb-run timeout 10s python -m src.main; then
            echo "App test result: PASSED (exited cleanly before timeout)"
          else
            exit_code=$?
            echo "Test command finished with exit code: $exit_code"
            if [ $exit_code -eq 124 ]; then
              echo "App test result: PASSED (ran for 10s without crashing)"
              exit 0 # Explicitly exit 0 to mark the step as successful
            else
              echo "App test result: FAILED (crashed with an unexpected error)"
              exit $exit_code # Exit with the original error code to fail the step
            fi
          fi

      - name: üìù Post Final Review Summary
        if: ${{ always() }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.APPROVER_TOKEN }}
          script: |
            // FIX: Check the step 'outcome' instead of 'conclusion' for a more reliable result.
            const lint_outcome = '${{ steps.lint.outcome }}';
            const format_outcome = '${{ steps.format_check.outcome }}';
            const test_outcome = '${{ steps.app_test.outcome }}';
            const pr_author = context.payload.pull_request.user.login;
            
            let review_body = `Hi @${pr_author}, I've finished my review!\n\nHere's the summary:\n\n`;
            let event = 'APPROVE';
            
            if (lint_outcome === 'success' && format_outcome === 'success') {
              review_body += '‚úÖ **Code Quality & Style:** Passed. Great job!\n';
            } else {
              review_body += '‚ùå **Code Quality & Style:** I found some issues. Please check my in-line comments for details. You can try running `/format` to fix style issues automatically.\n';
              event = 'REQUEST_CHANGES';
            }
            
            if (test_outcome === 'success') {
              review_body += '‚úÖ **Application Test:** Passed. The app launched successfully!\n';
            } else {
              review_body += '‚ùå **Application Test:** Failed. The app seems to crash on startup. Check the workflow logs for errors.\n';
              event = 'REQUEST_CHANGES';
            }
            
            if (event === 'APPROVE') {
              review_body += `\nEverything looks good to me. I'm approving this PR. Keep up the great work! üëç`;
            } else {
              review_body += `\nPlease address the feedback above. Let me know if you have any questions!`;
            }

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: event,
              body: review_body
            });