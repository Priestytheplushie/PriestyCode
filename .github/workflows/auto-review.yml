# .github/workflows/priestybot.yml
name: PriestyBot Review

on:
  pull_request:
    types: [review_requested] # Trigger only when a review is requested for a PR

permissions:
  contents: read          # Required to checkout the code
  pull-requests: write    # Required for PriestyBot to post reviews and comments
  security-events: write  # Required for CodeQL to upload results to Code Scanning
  checks: write           # Required for reviewdog to post inline annotations (check runs)

jobs:
  priestybot_review:
    runs-on: ubuntu-latest # The runner environment

    steps:
      - name: üõë Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.12.1

      - name: ‚¨áÔ∏è Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Important: Fetches the full history for 'black --diff' and 'isort --diff' to work correctly

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13' # Set to Python 3.13 as requested

      - name: üì¶ Cache Python Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-python-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-python-

      - name: üõ†Ô∏è Install System Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y xvfb jq

      - name: ‚ûï Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install mypy flake8 black isort

      - name: üê∂ Install Reviewdog
        uses: reviewdog/action-setup@v1
        with:
          reviewdog_version: latest

      - name: üìä Configure Git
        run: |
          git config user.name "PriestyBot"
          git config user.email "priestybot@users.noreply.github.com"

      - name: üëã Say Hello and Start Review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.issue.number;
            github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pr_number,
              body: "üëã Hello there! PriestyBot here, ready to review your pull request. I'm just getting started by checking for any previous review instructions or approvals. Please bear with me while I go through your amazing code! üòä"
            });

      # --- CodeQL Analysis Setup ---
      - name: üîç Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python

      - name: üèÉ‚Äç‚ôÇÔ∏è Run Linters and Post Inline Comments with Reviewdog
        id: linters_run
        env:
          REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.APPROVER_TOKEN }}
        run: |
          # Initialize flags for each linter's failure status
          # These flags will be set to 'true' if the linter finds issues.
          echo "MYPY_FAILED=false" >> "$GITHUB_ENV"
          echo "FLAKE8_FAILED=false" >> "$GITHUB_ENV"
          echo "BLACK_FAILED=false" >> "$GITHUB_ENV"
          echo "ISORT_FAILED=false" >> "$GITHUB_ENV"

          # Use a temporary file for overall linter status to ensure it's captured
          echo "LINTERS_OVERALL_STATUS=PASSED" > linter_overall_status.txt

          set -o pipefail # Ensure pipe failures are caught

          echo "Running MyPy (Type Checker)..."
          # Run MyPy, capture its output, and pipe to reviewdog.
          # If mypy finds errors, its exit code will be non-zero.
          # We use `tee` to capture output to a file and also pipe to reviewdog.
          mypy_output=$(mypy . --ignore-missing-imports 2>&1 || true)
          echo "MYPY_RAW_OUTPUT<<EOF" >> "$GITHUB_ENV"
          echo "$mypy_output"
          echo "EOF" >> "$GITHUB_ENV"
          
          # Pipe the captured output to reviewdog.
          echo "$mypy_output" | reviewdog -f=mypy -name="MyPy (Types)" -reporter=github-pr-review -level=warning -filter-mode=nofilter
          
          # Check for "Found X error" in mypy output to determine failure
          if echo "$mypy_output" | grep -q "Found [1-9][0-9]* error"; then
            echo "MYPY_FAILED=true" >> "$GITHUB_ENV"
            echo "LINTERS_OVERALL_STATUS=FAILED" > linter_overall_status.txt # Update overall status
          fi


          echo "Running Flake8..."
          flake8_output=$(flake8 . 2>&1 || true)
          echo "FLAKE8_RAW_OUTPUT<<EOF" >> "$GITHUB_ENV"
          echo "$flake8_output"
          echo "EOF" >> "$GITHUB_ENV"
          
          echo "$flake8_output" | reviewdog -f=flake8 -name="Flake8" -reporter=github-pr-review -level=warning -filter-mode=nofilter
          
          if [ -n "$flake8_output" ]; then # If output is not empty, there are errors
            echo "FLAKE8_FAILED=true" >> "$GITHUB_ENV"
            echo "LINTERS_OVERALL_STATUS=FAILED" > linter_overall_status.txt
          fi

          echo "Running Black (Code Formatter Check)..."
          # Run Black in check mode with diff. Capture all output.
          black_output=$(black --check --diff . 2>&1 || true)
          echo "BLACK_RAW_OUTPUT<<EOF" >> "$GITHUB_ENV"
          echo "$black_output"
          echo "EOF" >> "$GITHUB_ENV"
          
          # Pipe the diff output to reviewdog.
          echo "$black_output" | reviewdog -f=diff -f.diff.strip=1 -name="Black (Formatter)" -reporter=github-pr-review -filter-mode=nofilter
          
          if echo "$black_output" | grep -q "would reformat"; then
            echo "BLACK_FAILED=true" >> "$GITHUB_ENV"
            echo "Black found formatting issues."
            echo "LINTERS_OVERALL_STATUS=FAILED" > linter_overall_status.txt
          else
            echo "Black found no formatting issues. ‚ú®"
          fi

          echo "Running isort (Import Sorter Check)..."
          # Run isort in check-only mode with diff. Capture all output.
          isort_output=$(isort --check-only --diff . 2>&1 || true)
          echo "ISORT_RAW_OUTPUT<<EOF" >> "$GITHUB_ENV"
          echo "$isort_output"
          echo "EOF" >> "$GITHUB_ENV"
          
          # Pipe the diff output to reviewdog.
          echo "$isort_output" | reviewdog -f=diff -f.diff.strip=1 -name="isort (Import Sorter)" -reporter=github-pr-review -filter-mode=nofilter
          
          if echo "$isort_output" | grep -q "would be sorted"; then
            echo "ISORT_FAILED=true" >> "$GITHUB_ENV"
            echo "isort found import sorting issues."
            echo "LINTERS_OVERALL_STATUS=FAILED" > linter_overall_status.txt
          else
            echo "isort found no import sorting issues. ‚ú®"
          fi

          # Read the final overall status into an environment variable
          FINAL_LINTERS_STATUS=$(cat linter_overall_status.txt)
          echo "LINTERS_OVERALL_STATUS=$FINAL_LINTERS_STATUS" >> "$GITHUB_ENV"


      - name: üß™ Run Tkinter App Test
        id: app_test
        continue-on-error: true
        run: |
          echo "Running Tkinter App Test..."
          if xvfb-run timeout 10s python -m src.main; then
            echo "App test PASSED: Exited cleanly before timeout."
            echo "APP_TEST_STATUS=PASSED" >> "$GITHUB_ENV"
            echo "APP_TEST_REASON=Exited cleanly before timeout." >> "$GITHUB_ENV"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            exit_code=$?
            if [ $exit_code -eq 124 ]; then
              echo "App test PASSED: Ran for 10s and was terminated as expected."
              echo "APP_TEST_STATUS=PASSED" >> "$GITHUB_ENV"
              echo "APP_TEST_REASON=Ran for 10s and was terminated as expected." >> "$GITHUB_ENV"
              echo "status=success" >> $GITHUB_OUTPUT
            else
              echo "App test FAILED: App crashed with exit code $exit_code."
              echo "APP_TEST_STATUS=FAILED" >> "$GITHUB_ENV"
              echo "APP_TEST_REASON=App crashed with exit code $exit_code." >> "$GITHUB_ENV"
              echo "status=failure" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

      # --- CodeQL Analysis ---
      - name: üõ°Ô∏è Perform CodeQL Analysis
        id: codeql_analysis # Unique ID for this step
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:python" # Specify the language for analysis

      - name: üìù Generate and Post Final Summary Review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.issue.number;

            // Retrieve statuses from environment variables
            const app_test_status = process.env.APP_TEST_STATUS;
            const app_test_reason = process.env.APP_TEST_REASON;
            const linters_overall_status = process.env.LINTERS_OVERALL_STATUS;

            const mypy_failed = process.env.MYPY_FAILED === "true"; // Corrected to use "true" string
            const flake8_failed = process.env.FLAKE8_FAILED === "true"; // Corrected to use "true" string
            const black_failed = process.env.BLACK_FAILED === "true";
            const isort_failed = process.env.ISORT_FAILED === "true";

            // Access the outcome of the CodeQL analysis step directly from the `steps` context
            const codeql_analysis_outcome = '${{ steps.codeql_analysis.outcome }}';
            const codeqlPassed = (codeql_analysis_outcome === 'success');

            let reviewState = "REQUEST_CHANGES"; // Default review state
            let body = `### PriestyBot Final Review Summary\n\nHello again! Here's the complete summary of my review on your Python code:\n\n`;

            body += `* **Application Test:** ${app_test_status === 'PASSED' ? `Passed ‚úÖ (${app_test_reason})` : `Failed ‚ùå (${app_test_reason})`}\n`;
            body += `* **CodeQL Analysis:** ${codeqlPassed ? 'Passed ‚úÖ (Results available in Code Scanning tab)' : 'Failed ‚ùå (Please check workflow logs for details)'}\n`;
            body += `\n**Detailed Linter Results:**\n`;
            body += `* **MyPy (Types):** ${mypy_failed ? 'Failed ‚ùå' : 'Passed ‚úÖ'}\n`;
            body += `* **Flake8:** ${flake8_failed ? 'Failed ‚ùå' : 'Passed ‚úÖ'}\n`;
            body += `* **Black (Code Formatter):** ${black_failed ? 'Failed ‚ùå' : 'Passed ‚úÖ'}\n`;
            body += `* **isort (Import Sorter):** ${isort_failed ? 'Failed ‚ùå' : 'Passed ‚úÖ'}\n`;

            let linterFailuresDetails = [];

            // Add raw output for failed linters to details
            if (mypy_failed) {
              linterFailuresDetails.push(`MyPy Issues:\n\`\`\`\n${process.env.MYPY_RAW_OUTPUT}\n\`\`\``);
            }
            if (flake8_failed) {
              linterFailuresDetails.push(`Flake8 Issues:\n\`\`\`\n${process.env.FLAKE8_RAW_OUTPUT}\n\`\`\``);
            }
            if (black_failed) {
              linterFailuresDetails.push(
                "Black detected formatting issues. The following changes would be applied:\n" +
                "```diff\n" + process.env.BLACK_RAW_OUTPUT + "\n```\n\n" +
                "You can automatically fix these by commenting `/format` on the pull request."
              );
            }
            if (isort_failed) {
              linterFailuresDetails.push(
                "Isort detected import sorting issues. The following changes would be applied:\n" +
                "```diff\n" + process.env.ISORT_RAW_OUTPUT + "\n```\n\n" +
                "You can automatically fix these by commenting `/format` on the pull request."
              );
            }

            if (linters_overall_status === "FAILED" || !codeqlPassed) {
              body += `\n\nI found some issues during the review. **Please check the inline comments I've left directly on the code in the 'Files changed' tab for specific details.**\n`;
              if (linterFailuresDetails.length > 0) {
                body += "\nHere are some details on the issues found:\n\n";
                body += linterFailuresDetails.join("\n\n");
                body += "\n";
              }
              body += `\nRemember, these linter suggestions are advisory. If you've reviewed them and believe they are not applicable, or if you wish to proceed anyway, you can always use the \`/approve\` command. Your decision is final!`;
            } else {
                body += `\n\nAll linters passed! üéâ Your code looks sparkling clean and follows our style guidelines beautifully!`;
            }

            let final_message;

            // Determine the review event type and final message based on results
            if (app_test_status === 'FAILED') {
              event_type = 'REQUEST_CHANGES';
              final_message = "\n\n**Decision: Requesting Changes**\n\nUnfortunately, I have to request changes because the application tests failed. This is a critical issue that needs to be addressed. Please fix the issues and push your changes so I can review again. I'm here to help if you get stuck! üòä";
            } else if (linters_overall_status === "FAILED" || !codeqlPassed) {
              event_type = 'REQUEST_CHANGES';
              final_message = "\n\n**Decision: Requesting Changes**\n\nBased on the linter or CodeQL findings, I'm requesting changes. Please review the details above and any inline comments. Remember, linters are advisory, and you can use `/approve` to bypass them if needed. For CodeQL findings, please check the 'Security' tab of your repository. Let's get this code polished! ‚ú®";
            } else {
              event_type = 'APPROVE';
              final_message = "\n\n**Decision: Approved!**\n\nEverything looks absolutely fantastic! Both the application tests and all linters/security checks passed with flying colors. Great job! üëç Your code is ready to merge! Keep up the amazing work! ü•≥";
            }

            // Post the final review
            await github.rest.pulls.createReview({
              owner,
              repo,
              pull_number: pr_number,
              body: body + final_message, // Combine summary and final message
              event: event_type,
            });
