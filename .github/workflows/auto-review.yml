name: PriestyBot Auto-Review & CodeQL

on:
  push:
    branches:
      - main
  pull_request:
    types: [review_requested, synchronize]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  checks: write
  security-events: write

jobs:
  lint-and-test:
    name: Lint & Test
    if: |
      (github.event.action == 'review_requested' && github.event.requested_reviewer.login == 'PriestyBot') ||
      (github.event.action == 'synchronize' && contains(github.event.pull_request.labels.*.name, 'priestybot-review'))
    runs-on: ubuntu-latest
    env:
      REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.APPROVER_TOKEN }}
    outputs:
      flake8_outcome: ${{ steps.flake8.conclusion }}
      black_outcome: ${{ steps.black.conclusion }}
      isort_outcome: ${{ steps.isort.conclusion }}
      bandit_outcome: ${{ steps.bandit.conclusion }}
      mypy_outcome: ${{ steps.mypy.conclusion }}
      app_test_outcome: ${{ steps.app_test.outcome }}
    steps:
      - name: Add 'priestybot-review' Label
        if: github.event.action == 'review_requested'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['priestybot-review']
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `Hey @${context.payload.pull_request.user.login}! ðŸ‘‹ Thanks for the review request. I'll get started right away and will keep an eye on this PR for any new changes. ðŸ§`
            });

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Set up reviewdog
        uses: reviewdog/action-setup@v1
        with:
          reviewdog_version: latest

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install flake8 black isort mypy bandit

      # FIXED: Converted flake8 to a manual run step for consistency and correctness
      - name: ðŸ’§ Run Linter (flake8)
        id: flake8
        continue-on-error: true
        run: |
          flake8 src | reviewdog -f=flake8 -name="flake8-check" -reporter=github-pr-check -level=warning -filter-mode="nofilter" -fail-level=warning

      # FIXED: Converted black to a manual run step for consistency and correctness
      - name: ðŸ’… Run Format Check (black)
        id: black
        continue-on-error: true
        run: |
          black --check src | reviewdog -f=black -name="black-check" -reporter=github-pr-check -level=warning -filter-mode="nofilter" -fail-level=warning
      
      - name: sorted? Run Import Sort Check (isort)
        id: isort
        continue-on-error: true
        run: |
          isort --check src | reviewdog -f=isort -name="isort-check" -reporter=github-pr-check -level=warning -filter-mode="nofilter" -fail-level=warning
      
      - name: ðŸ”’ Run Security Check (bandit)
        id: bandit
        continue-on-error: true
        run: |
          bandit -r src -f txt | reviewdog -f=bandit -name="bandit-check" -reporter=github-pr-check -level=error -filter-mode="nofilter" -fail-level=error

      - name: ðŸ§ Run Type Check (mypy)
        id: mypy
        continue-on-error: true
        run: |
          mypy src | reviewdog -f=mypy -name="mypy-check" -reporter=github-pr-check -level=error -filter-mode="nofilter" -fail-level=error

      - name: ðŸ§ª Run Tkinter App Test
        id: app_test
        continue-on-error: true
        run: |
          echo "Starting the Tkinter app in a virtual display..."
          if xvfb-run timeout 10s python -m src.main; then
            echo "App test result: PASSED (exited cleanly before timeout)"
          else
            exit_code=$?
            if [ $exit_code -eq 124 ]; then
              echo "App test result: PASSED (ran for 10s without crashing)"
              exit 0
            else
              echo "App test result: FAILED (crashed with an unexpected error)"
              exit $exit_code
            fi
          fi

  codeql:
    name: CodeQL Analysis
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event.action == 'review_requested' && github.event.requested_reviewer.login == 'PriestyBot') ||
      (github.event.action == 'synchronize' && contains(github.event.pull_request.labels.*.name, 'priestybot-review'))
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
    outputs:
      analyze_outcome: ${{ steps.analyze.outcome }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.ref }}
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python
          config-file: ./.github/codeql/codeql-config.yml
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
      - name: Perform CodeQL Analysis
        id: analyze
        uses: github/codeql-action/analyze@v3

  final-review:
    name: Post Final Review
    if: always() && needs.lint-and-test.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [lint-and-test, codeql]
    steps:
      - name: ðŸ“ Post Final Review Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            // This script should now receive the correct step conclusions and work as intended.
            const pr_author = context.payload.pull_request.user.login;
            const lintJobResult = '${{ needs.lint-and-test.result }}';
            const codeqlJobResult = '${{ needs.codeql.result }}';
            let review_body = `Hi @${pr_author}, I've finished my review!\n\n`;
            let event = 'APPROVE';

            // Check for job-level crashes first
            if (lintJobResult === 'failure' && '${{ needs.lint-and-test.outputs.isort_conclusion }}' === '') { // Heuristic for job crash
              event = 'REQUEST_CHANGES';
              review_body += `âŒ **Workflow Error:** The 'Lint & Test' job failed unexpectedly. This is usually due to a configuration issue in the workflow file itself, not a problem with your code.\n\n`;
              review_body += `Please check the workflow logs in the "Checks" tab for the exact error message. I cannot approve this PR until the workflow runs successfully.`;
            } else {
              const outcomes = {
                flake8: { conclusion: `${{ needs.lint-and-test.outputs.flake8_outcome }}`, isBlocker: false, title: `ðŸŽ¨ Linting Issues (\`flake8\`)` },
                black: { conclusion: `${{ needs.lint-and-test.outputs.black_outcome }}`, isBlocker: false, title: `ðŸŽ¨ Formatting & Style (\`black\`)` },
                isort: { conclusion: `${{ needs.lint-and-test.outputs.isort_outcome }}`, isBlocker: false, title: `ðŸŽ¨ Import Order (\`isort\`)` },
                bandit: { conclusion: `${{ needs.lint-and-test.outputs.bandit_outcome }}`, isBlocker: true, title: `ðŸš¨ Security Analysis (\`bandit\`)` },
                mypy: { conclusion: `${{ needs.lint-and-test.outputs.mypy_outcome }}`, isBlocker: true, title: `ðŸš¨ Type Checking (\`mypy\`)` },
                app_test: { conclusion: `${{ needs.lint-and-test.outputs.app_test_outcome }}`, isBlocker: true, title: `ðŸš¨ Application Test` },
                codeql: { conclusion: `${{ needs.codeql.outputs.analyze_outcome }}`, isBlocker: true, title: `ðŸš¨ Advanced Security (\`CodeQL\`)` }
              };
              
              const fix_guides = {
                  flake8: `I have left inline comments with the details. Please review them and apply the suggested fixes.`,
                  black: `You can run \`black src\` locally to fix this. For an even easier fix, just **comment \`/format\` on this PR**, and I will do it for you!`,
                  isort: `You can run \`isort src\` locally. This will also be fixed automatically if you use the **\`/format\`** command.`,
                  bandit: `Please check my inline comments for the specific vulnerability and how to address it.`,
                  mypy: `Check the \`mypy\` logs in the "Checks" tab for the exact line and error, or review my inline comments.`,
                  app_test: `The app failed to run for 10 seconds. Please check the workflow logs in the "Lint & Test" job for the full error message.`,
                  codeql: `Go to the **'Security' tab** of this repository, find the new 'Code scanning alert' for this pull request, and follow the detailed remediation advice provided there.`
              };

              const blockers = Object.keys(outcomes).filter(key => outcomes[key].isBlocker && outcomes[key].conclusion === 'failure');
              const suggestions = Object.keys(outcomes).filter(key => !outcomes[key].isBlocker && outcomes[key].conclusion === 'failure');

              if (blockers.length === 0 && suggestions.length === 0) {
                review_body += `Everything looks great! All checks passed. Keep up the fantastic work! ðŸ‘`;
              } else {
                if (blockers.length > 0) { event = 'REQUEST_CHANGES'; }

                if (blockers.length > 0) {
                  review_body += `I've found a few critical issues (ðŸš¨) that need your attention before this can be merged. Here's a breakdown:\n\n---\n\n`;
                  for (const key of blockers) { review_body += `*   **${outcomes[key].title}**\n    *   **To Fix:** ${fix_guides[key]}\n\n`; }
                }
                if (suggestions.length > 0) {
                  if (blockers.length === 0) {
                     review_body += `Everything looks good to merge, but I have a few minor suggestions (ðŸŽ¨) to improve the code:\n\n---\n\n`;
                  } else {
                     review_body += `I also found some minor suggestions:\n\n`;
                  }
                  for (const key of suggestions) { review_body += `*   **${outcomes[key].title}**\n    *   **To Fix:** ${fix_guides[key]}\n\n`; }
                }
                if (event === 'REQUEST_CHANGES') {
                  review_body += `\nPlease address the blocking issues. Let me know if you have questions!`;
                } else {
                  review_body += `\nSince there are no blocking issues, I'm approving this PR. Great work!`;
                }
              }
            }

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: event,
              body: review_body
            });
            
            if (event === 'APPROVE') {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: 'priestybot-review'
                });
              } catch (error) {
                console.log("Could not remove 'priestybot-review' label, it might not exist or already be removed.");
              }
            }
