# .github/workflows/priestybot-commands.yml
# Refactored for better modularity and maintainability.

name: PriestyBot Commands

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [synchronize] # When new commits are pushed to the PR branch
  pull_request_review_comment:
    types: [created] # When a suggestion is committed via a review comment

permissions:
  contents: write
  pull-requests: write

jobs:
  # Job 1: Parse the incoming command from the issue comment
  parse-command:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request && github.actor != 'PriestyBot'
    runs-on: ubuntu-latest
    outputs:
      command: ${{ steps.parser.outputs.command }}
      message: ${{ steps.parser.outputs.message }}
      pr_number: ${{ steps.pr_info.outputs.pr_number }}
      commenter: ${{ steps.pr_info.outputs.commenter }}
      base_branch: ${{ steps.pr_info.outputs.base_branch }}
      head_branch: ${{ steps.pr_info.outputs.head_branch }}
      repo_name: ${{ steps.pr_info.outputs.repo_name }}
      is_admin: ${{ steps.check_admin.outputs.is_admin }}
    steps:
      - name: Parse Command
        id: parser
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.comment.body.trim();
            if (!body.startsWith('/')) {
              console.log("Comment is not a command.");
              core.setOutput('command', 'no_command');
              return;
            }
            const args = body.split(/\s+/);
            const command = args[0].substring(1);
            const message = args.slice(1).join(' ');

            const validCommands = ['help', 'approve', 'request-changes', 'comment', 'format', 'lint', 'merge', 'squash', 'rebase', 'resolve','release','tag'];

            if (!validCommands.includes(command)) {
              console.log(`Unknown command: ${command}`);
              core.setOutput('command', 'unknown');
              return;
            }

            core.setOutput('command', command);
            core.setOutput('message', message);
            console.log(`Command: ${command}, Message: ${message}`);

      - name: Get PR Info and Commenter
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const pr_number = context.issue.number;
            const commenter = context.payload.comment.user.login;
            const { data: pull_request } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
            });

            core.setOutput('pr_number', pr_number);
            core.setOutput('commenter', commenter);
            core.setOutput('base_branch', pull_request.base.ref);
            core.setOutput('head_branch', pull_request.head.ref);
            core.setOutput('repo_name', context.repo.owner + '/' + context.repo.repo);
            core.exportVariable('BOT_USERNAME', 'PriestyBot');
            # Changed: Export a simple tag, the HTML comment is constructed where used
            core.exportVariable('BOT_REVIEW_TAG_RAW', 'BOT_REVIEW_TAG');

      - name: Check Admin Status
        id: check_admin
        if: contains('merge squash rebase', steps.parser.outputs.command)
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const { data: permissions } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: context.payload.comment.user.login,
            });
            const isAdmin = permissions.permission === 'admin' || permissions.permission === 'maintain';
            core.setOutput('is_admin', isAdmin ? 'true' : 'false');
            console.log(`User ${context.payload.comment.user.login} is admin: ${isAdmin}`);

  # Job 2: Acknowledge the command (runs for any valid command)
  acknowledge-command:
    needs: parse-command
    if: needs.parse-command.outputs.command != 'unknown' && needs.parse-command.outputs.command != 'no_command'
    runs-on: ubuntu-latest
    steps:
      - name: Acknowledge Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const command = JSON.stringify("${{ needs.parse-command.outputs.command }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            let acknowledgmentMessage = ``;
            switch (JSON.parse(command)) {
              case 'resolve':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, received your \`/resolve\` command! I'm now checking for merge conflicts and will provide an update shortly.`;
                break;
              case 'approve':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, got it! I'm processing your \`/approve\` request now.`;
                break;
              case 'request-changes':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, understood! I'm marking this PR for changes based on your \`/request-changes\` command.`;
                break;
              case 'comment':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, thanks for the note! I'm adding your comment now.`;
                break;
              case 'format':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, starting the code formatting process with \`/format\`! I'll let you know when it's done.`;
                break;
              case 'lint':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, running the linting checks as requested with \`/lint\`! I'll post a summary here soon.`;
                break;
              case 'merge':
              case 'squash':
              case 'rebase':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, I'm initiating the \`/${JSON.parse(command)}\` operation. I'll confirm once it's complete, or let you know if there are any issues.`;
                break;
              case 'help':
                acknowledgmentMessage = `@${JSON.parse(commenter)}, I'm preparing the help message for you now!`;
                break;
              default:
                acknowledgmentMessage = `@${JSON.parse(commenter)}, processing your command...`;
                break;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: acknowledgmentMessage
            });

  # Job 3: Handle /resolve command
  handle-resolve:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'resolve'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.run_resolver_script.outputs.status }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.parse-command.outputs.head_branch }}
          fetch-depth: 0
          token: '${{ secrets.APPROVER_TOKEN }}'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-python-3.11-pip-PyGithub-${{ hashFiles('.github/scripts/conflict_resolver.py') }}
          restore-keys: |
            ${{ runner.os }}-python-3.11-pip-PyGithub-
            ${{ runner.os }}-python-3.11-pip-

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyGithub

      - name: Execute Conflict Resolver Script
        id: run_resolver_script
        env:
          PR_NUMBER: ${{ needs.parse-command.outputs.pr_number }}
          BASE_BRANCH: ${{ needs.parse-command.outputs.base_branch }}
          HEAD_BRANCH: ${{ needs.parse-command.outputs.head_branch }}
          REPO_NAME: ${{ needs.parse-command.outputs.repo_name }}
          BOT_USERNAME: PriestyBot
          # Changed: Pass the RAW tag. The script constructs the HTML comment
          BOT_REVIEW_TAG_RAW: BOT_REVIEW_TAG
          GH_TOKEN: ${{ secrets.APPROVER_TOKEN }}
        run: |
          python ${{ github.workspace }}/.github/scripts/conflict_resolver.py
        continue-on-error: true

      - name: Post Success Message for /resolve (Conflicts Handled)
        if: steps.run_resolver_script.outcome == 'success' && steps.run_resolver_script.outputs.status == 'conflicts_posted'
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: `@${JSON.parse(commenter)} Hey! I've posted a new review with merge conflict suggestions for you to check out in the 'Files changed' tab. Let me know if you need a hand!`
            });

      - name: Post Message for /resolve (No Conflicts Found)
        if: steps.run_resolver_script.outcome == 'success' && steps.run_resolver_script.outputs.status == 'no_conflicts'
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: `@${JSON.parse(commenter)} ‚ú® Good news! I've checked, and there are currently no merge conflicts detected on this Pull Request. You're all clear to proceed!`
            });

      - name: Post Error Message for /resolve Command Failure
        if: steps.run_resolver_script.outcome == 'failure' || steps.run_resolver_script.outputs.status == 'error'
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: `@${JSON.parse(commenter)} ‚ùå Oops! I encountered an issue while trying to process merge conflicts for this PR. My apologies! Please check the workflow run logs for details, or try resolving manually.`
            });

  # Job 4: Handle /approve command
  handle-approve:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'approve'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /approve Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const message = JSON.stringify("${{ needs.parse-command.outputs.message }}");
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const body = JSON.parse(message) ? JSON.parse(message) : undefined;
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: JSON.parse(pr_number),
              event: 'APPROVE',
              body: body
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: `@${JSON.parse(commenter)} ‚úÖ Approved this Pull Request! Looking good!`
            });

  # Job 5: Handle /request-changes command
  handle-request-changes:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'request-changes'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /request-changes Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const message = JSON.stringify("${{ needs.parse-command.outputs.message }}");
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const body = JSON.parse(message) ? JSON.parse(message) : undefined;
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: JSON.parse(pr_number),
              event: 'REQUEST_CHANGES',
              body: body
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: `@${JSON.parse(commenter)} üìù Changes requested on this Pull Request. Please take a look!`
            });

  # Job 6: Handle /comment command
  handle-comment:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'comment'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /comment Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const message = JSON.stringify("${{ needs.parse-command.outputs.message }}");
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            if (!JSON.parse(message)) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚ö†Ô∏è To use the \`/comment\` command, please provide a message. Example: \`/comment This is my message.\``
              });
              core.setFailed('Comment command requires a message.');
              return;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: `@${JSON.parse(commenter)} Your comment has been added: "${JSON.parse(message)}"`
            });

  # Job 7: Handle /help command
  handle-help:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'help'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /help Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const helpMessage = `
            @${JSON.parse(commenter)} Hey there! I'm PriestyBot, your automated teammate here to help streamline our development workflow! Here are the commands you can use with me:

            My main purpose is to automate common tasks and provide quick feedback directly on your PRs, making our CI/CD process smoother and more efficient.

            ---

            ### Commands I Understand:

            <details>
            <summary>‚ú® Click to expand / collapse command descriptions ‚ú®</summary>

            #### \`/help\`
            * **Purpose:** Displays this comprehensive help message, listing all available commands and explaining my role.
            * **Usage:** \`/help\`

            #### \`/approve [message]\`
            * **Purpose:** Approves the Pull Request. This is useful for quickly signaling that the changes look good to you.
            * **Usage:** \`/approve\` or \`/approve Looks great, ready to merge!\`
            * **Note:** This acts as a formal GitHub review.

            #### \`/request-changes [message]\`
            * **Purpose:** Requests changes on the Pull Request. Use this to indicate that the PR needs modifications before it can be merged.
            * **Usage:** \`/request-changes\` or \`/request-changes Please address the linting issues.\`
            * **Note:** This also acts as a formal GitHub review and will block the PR from merging until the requested changes are resolved.

            #### \`/comment <message>\`
            * **Purpose:** Leaves a general comment on the Pull Request. Great for quick notes or discussions that don't require a formal review.
            * **Usage:** \`/comment Let's discuss this approach in our stand-up.\`
            * **Important:** This command requires you to provide a message!

            #### \`/format [message]\`
            * **Purpose:** Automatically formats the code in your Pull Request using \`black\` and \`isort\`. If changes are applied, I'll commit them directly to your branch.
            * **Usage:** \`/format\` (for default commit message) or \`/format Applied formatting for new feature\` (for custom commit message).
            * **Benefit:** Helps maintain consistent code style across the repository.

            #### \`/lint\`
            * **Purpose:** Runs various linting checks (\`mypy\`, \`isort\`, \`black\` in check mode, \`flake8\`) on your code. I'll post a summary comment with collapsible details for each linter's output.
            * **Usage:** \`/lint\`
            * **Benefit:** Provides quick, actionable feedback on potential code quality, style, and type issues without blocking your PR. These are suggestions, not formal review requests.

            #### \`/resolve\`
            * **Purpose:** Triggers me to check for and suggest resolutions for merge conflicts on this PR. If conflicts are found, I'll post a "Changes Requested" review with inline suggestions to guide you through fixing them. I'll also automatically re-check and dismiss my review once conflicts are resolved.
            * **Usage:** \`/resolve\`
            * **Benefit:** Helps you quickly identify and fix merge conflicts, unblocking your PR for further checks and merging.

            #### \`/merge\` (Admin Only)
            * **Purpose:** Merges the Pull Request into the base branch using a standard merge commit.
            * **Usage:** \`/merge\`
            * **Restriction:** Only users with admin/maintainer permissions can use this command. I'll let you know if the PR isn't mergeable (e.g., due to conflicts or pending checks).

            #### \`/squash\` (Admin Only)
            * **Purpose:** Squashes all commits in the Pull Request into a single commit and then merges it into the base branch.
            * **Usage:** \`/squash\`
            * **Restriction:** Only users with admin/maintainer permissions can use this command. I'll let you know if the PR isn't mergeable.

            #### \`/rebase\` (Admin Only)
            * **Purpose:** Rebases your Pull Request's commits onto the base branch and then merges it.
            * **Usage:** \`/rebase\`
            * **Restriction:** Only users with admin/maintainer permissions can use this command. I'll let you know if the PR isn't mergeable.

            #### \`/release <patch|minor|major>\` (Develop Branch Only)
            * **Purpose:** Creates a new pre-release tag on the \`develop\` branch with a semantic version bump and a \`-beta.N\` suffix. Use this to mark your PR for pre-release testing before merging.
            * **Usage:** \`/release patch\`, \`/release minor\`, or \`/release major\`
            * **Behavior:** Automatically calculates and creates the next pre-release tag (e.g. \`v0.2.1-beta.3\`) and pushes it to GitHub. You'll get a confirmation comment with the tag name to use for deployment.
            * **Note:** Only works on PRs targeting the \`develop\` branch. Use at the end of your PR lifecycle to prepare a testable pre-release.

            </details>

            ---

            ### About PriestyBot and CI/CD:

            I'm here to complement our Continuous Integration (CI) process. Sometimes, CI checks might not even start if your Pull Request has merge conflicts. That's where I come in!

            * **Automated Code Review (My Role):** I can perform quick, automated checks like formatting (\`/format\`) and linting (\`/lint\`). These are designed to give you immediate, actionable feedback via inline comments, helping you catch issues early. Think of these as helpful suggestions from an automated teammate, not formal blocking reviews.
            * **Conflict Resolution:** My \`/resolve\` command helps you quickly address conflicts, which then allows our regular CI checks (like tests and builds) to run smoothly.
            * **Pre-Checks:** Commands like \`/format\` and \`/lint\` allow you to proactively check and fix common issues before they're caught by the main CI pipeline, saving time and resources.
            * **Streamlined Merging:** For admins, I can help with the final merge steps, ensuring the PR is ready for integration.

            **Automated Formal Reviews (Triggered by GitHub's "Request Reviewers"):**
            I also have a separate workflow (\`auto-review.yml\`) that runs a more comprehensive, formal review. This is triggered when you use GitHub's built-in "Request Reviewers" feature and select **PriestyBot** as a reviewer. When I perform this review, I'll:
            * Run a full suite of linting checks (mypy, flake8, black, isort).
            * Execute critical application tests.
            * Post a detailed review summary directly on your PR, which might include requesting changes if critical issues are found, or approving if everything looks good.

            **Important Note on Human Reviews:**
            While I can help with quick approvals and change requests, and even provide an automated formal review, for a comprehensive, human-driven review, please use GitHub's built-in "Request Reviewers" feature and select your human teammates. This ensures your code gets the thorough human attention it deserves!

            ---
            Let me know if you have any other questions or if there's anything else I can assist with! Happy coding!
            `;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: helpMessage
            });


  # Job 8: Handle /format command
  handle-format:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'format'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code for Format
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.parse-command.outputs.head_branch }}
          token: '${{ secrets.APPROVER_TOKEN }}'
      - name: Setup Python for Format
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install Formatters (Black, isort)
        run: pip install black isort
      - name: Run Formatters
        id: run_formatters
        run: |
          isort .
          black .
          # Check if any changes were made by either formatter
          if git diff --exit-code; then
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true # Allow subsequent steps to run even if formatters make changes
      - name: Commit and Push Formatted Changes
        if: steps.run_formatters.outputs.changes_made == 'true'
        run: |
          git config user.name "PriestyBot"
          git config user.email "PriestyBot@users.noreply.github.com"
          git add .

          # Determine commit message
          FORMAT_MESSAGE="${{ needs.parse-command.outputs.message }}"
          if [ -z "$FORMAT_MESSAGE" ]; then
            COMMIT_MESSAGE="chore: Apply code formatting by PriestyBot"
          else
            COMMIT_MESSAGE="chore: Format code - $FORMAT_MESSAGE"
          fi
          git commit -m "$COMMIT_MESSAGE"
          git push origin HEAD:${{ needs.parse-command.outputs.head_branch }}
      - name: Post Format Status
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const changesMade = JSON.stringify("${{ steps.run_formatters.outputs.changes_made }}");
            let message;
            if (JSON.parse(changesMade) === 'true') {
              message = `@${JSON.parse(commenter)} ‚úÖ Code formatting applied and pushed to PR #${JSON.parse(pr_number)}. You should see the changes reflected shortly!`;
            } else {
              message = `@${JSON.parse(commenter)} ‚ÑπÔ∏è Great news! Your code is already well-formatted. No changes were needed for PR #${JSON.parse(pr_number)}.`;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: JSON.parse(pr_number),
              body: message
            });

  # Job 9: Handle /lint command
  handle-lint:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'lint'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code for Lint
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.parse-command.outputs.head_branch }}
          token: '${{ secrets.APPROVER_TOKEN }}'
      - name: Setup Python for Lint
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install Linters
        run: pip install black flake8 isort mypy
      - name: Run Linters
        id: run_linters
        run: |
          LINT_STATUS="PASSED" # Overall linting status

          echo "--- Running flake8 ---"
          if ! flake8_output=$(flake8 . 2>&1); then
            echo "$flake8_output" > flake8_report.txt
            echo "flake8_failed=true" >> $GITHUB_OUTPUT
            LINT_STATUS="FAILED"
          else
            echo "flake8_failed=false" >> $GITHUB_OUTPUT
          fi

          echo "--- Running black (check mode) ---"
          if ! black_output=$(black --check --diff . 2>&1); then
            echo "$black_output" > black_report.txt
            echo "black_failed=true" >> $GITHUB_OUTPUT
            LINT_STATUS="FAILED"
          else
            echo "black_failed=false" >> $GITHUB_OUTPUT
          fi

          echo "--- Running isort (check mode) ---"
          if ! isort_output=$(isort --check --diff . 2>&1); then
            echo "$isort_output" > isort_report.txt
            echo "isort_failed=true" >> $GITHUB_OUTPUT
            LINT_STATUS="FAILED"
          else
            echo "isort_failed=false" >> $GITHUB_OUTPUT
          fi

          echo "--- Running mypy ---"
          if ! mypy_output=$(mypy . 2>&1); then
            echo "$mypy_output" > mypy_report.txt
            echo "mypy_failed=true" >> $GITHUB_OUTPUT
            LINT_STATUS="FAILED"
          else
            echo "mypy_failed=false" >> $GITHUB_OUTPUT
          fi

          echo "overall_lint_status=$LINT_STATUS" >> $GITHUB_OUTPUT
        continue-on-error: true # Allow subsequent steps to run even if linting issues are found

      - name: Post Lint Status
        uses: actions/github-script@v7
        env:
          FLAKE8_FAILED: ${{ steps.run_linters.outputs.flake8_failed }}
          BLACK_FAILED: ${{ steps.run_linters.outputs.black_failed }}
          ISORT_FAILED: ${{ steps.run_linters.outputs.isort_failed }}
          MYPY_FAILED: ${{ steps.run_linters.outputs.mypy_failed }}
          COMMENTER: ${{ needs.parse-command.outputs.commenter }}
          PR_NUMBER: ${{ needs.parse-command.outputs.pr_number }}
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const fs = require('fs');
            const commenter = process.env.COMMENTER;
            const pr_number = parseInt(process.env.PR_NUMBER, 10);

            const flake8Failed = process.env.FLAKE8_FAILED === 'true';
            const blackFailed = process.env.BLACK_FAILED === 'true';
            const isortFailed = process.env.ISORT_FAILED === 'true';
            const mypyFailed = process.env.MYPY_FAILED === 'true';

            function getReport(name) {
              const filePath = `${name}_report.txt`;
              if (fs.existsSync(filePath)) {
                let content = fs.readFileSync(filePath, 'utf8').trim();
                if (name === 'black' || name === 'isort') {
                  content = content.split('\n').filter(line =>
                    !line.startsWith('--- ') &&
                    !line.startsWith('+++ ') &&
                    !line.startsWith('@@ ') &&
                    !line.startsWith('diff ')
                  ).join('\n').trim();
                }
                return content || `_No issues found for ${name}._`;
              }
              return `_No report file found for ${name}._`;
            }

            let message = `@${commenter} Here's the linting report for PR #${pr_number}:\n\n`;

            const anyFailed = flake8Failed || blackFailed || isortFailed || mypyFailed;

            if (!anyFailed) {
              message += 'üéâ **All linting checks passed!** Your code looks super clean. Great job!\n\n';
            } else {
              message += '‚ö†Ô∏è **Linting found some areas for improvement.** Please check the details below for each linter. You\'ll find specific issues highlighted in the collapsible sections.\n\n';
            }

            message += `### Linting Report Summary:\n\n`;

            message += `<details>\n<summary>üìù **flake8:** ${flake8Failed ? '‚ùå Issues Found' : '‚úÖ Looks Good!' }</summary>\n\n\`\`\`\n${getReport('flake8')}\n\`\`\`\n\n</details>\n\n`;
            message += `<details>\n<summary>‚ú® **Black (Formatting):** ${blackFailed ? '‚ùå Needs Formatting' : '‚úÖ Well Formatted!' }</summary>\n\n\`\`\`diff\n${getReport('black')}\n\`\`\`\n\n</details>\n\n`;
            message += `<details>\n<summary>‚û°Ô∏è **isort (Imports):** ${isortFailed ? '‚ùå Imports Need Sorting' : '‚úÖ Imports Sorted!' }</summary>\n\n\`\`\`diff\n${getReport('isort')}\n\`\`\`\n\n</details>\n\n`;
            message += `<details>\n<summary>üßê **mypy (Type Checking):** ${mypyFailed ? '‚ùå Type Errors Detected' : '‚úÖ No Type Errors!' }</summary>\n\n\`\`\`\n${getReport('mypy')}\n\`\`\`\n\n</details>\n\n`;

            message += `---\n\n`;

            message += `üí° **Want me to help fix some of these automatically?**\n`;
            message += `* For formatting (Black and isort), try using the \`/format\` command!\n`;
            message += `* If you'd like me to provide **inline comments** directly on the lines with issues, please use GitHub's "Request Reviewers" feature and select **PriestyBot** as a reviewer. This will trigger my automated formal review workflow.\n\n`;
            message += `Let me know if you have any questions or need a hand!`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: message
            });


  # Job 10: Handle /merge command
  handle-merge:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'merge' && needs.parse-command.outputs.is_admin == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /merge Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const head_branch = JSON.stringify("${{ needs.parse-command.outputs.head_branch }}");
            const { data: pull_request } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: JSON.parse(pr_number),
            });

            if (!pull_request.mergeable) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚ö†Ô∏è This PR cannot be merged automatically right now (it's not mergeable, likely due to conflicts or pending checks). Please use \`/resolve\` or address other blocking issues first.`
              });
              return;
            }

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: JSON.parse(pr_number),
                merge_method: 'merge', # Fast-forward merge if possible, otherwise a merge commit
                commit_title: `Merge pull request #${JSON.parse(pr_number)} from ${JSON.parse(head_branch)}`,
                commit_message: `Merged by @${JSON.parse(commenter)} via PriestyBot.`
              });
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚úÖ PR #${JSON.parse(pr_number)} merged successfully! Great work team!`
            });
            } catch (error) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚ùå Failed to merge PR #${JSON.parse(pr_number)}. Error: ${error.message}`
              });
              core.setFailed(`Failed to merge PR: ${error.message}`);
            }

  # Job 11: Handle /squash command
  handle-squash:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'squash' && needs.parse-command.outputs.is_admin == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /squash Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const head_branch = JSON.stringify("${{ needs.parse-command.outputs.head_branch }}");
            const { data: pull_request } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: JSON.parse(pr_number),
            });

            if (!pull_request.mergeable) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚ö†Ô∏è This PR cannot be squashed automatically right now (it's not mergeable, likely due to conflicts or pending checks). Please use \`/resolve\` or address other blocking issues first.`
              });
              return;
            }

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: JSON.parse(pr_number),
                merge_method: 'squash',
                commit_title: `Squash merge of pull request #${JSON.parse(pr_number)} from ${JSON.parse(head_branch)}`,
                commit_message: `Squashed by @${JSON.parse(commenter)} via PriestyBot.\n\n${pull_request.title}\n\n${pull_request.body}`
              });
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚úÖ PR #${JSON.parse(pr_number)} squashed and merged successfully! Awesome!`
              });
            } catch (error) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚ùå Failed to squash merge PR #${JSON.parse(pr_number)}. Error: ${error.message}`
              });
              core.setFailed(`Failed to squash merge PR: ${error.message}`);
            }

  # Job 12: Handle /rebase command
  handle-rebase:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'rebase' && needs.parse-command.outputs.is_admin == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /rebase Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const { data: pull_request } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: JSON.parse(pr_number),
            });

            if (!pull_request.mergeable) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚ö†Ô∏è This PR cannot be rebased automatically right now (it's not mergeable, likely due to conflicts or pending checks). Please use \`/resolve\` or address other blocking issues first.`
              });
              return;
            }

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: JSON.parse(pr_number),
                merge_method: 'rebase'
              });
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚úÖ PR #${JSON.parse(pr_number)} rebased and merged successfully! Fantastic!`
              });
            } catch (error) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: JSON.parse(pr_number),
                body: `@${JSON.parse(commenter)} ‚ùå Failed to rebase merge PR #${JSON.parse(pr_number)}. Error: ${error.message}`
              });
              core.setFailed(`Failed to rebase merge PR: ${error.message}`);
            }

  # Job 13: Handle unknown command
  handle-unknown-command:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'unknown'
    runs-on: ubuntu-latest
    steps:
      - name: Handle Unknown Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const body = `@${JSON.parse(commenter)} ü§î I don't recognize that command. Please use \`/help\` for a list of available commands.`
            await github.rest.issues.createComment({ ...context.repo, issue_number: JSON.parse(pr_number), body });

  # Job 14: Deny Admin Command (if user is not admin)
  deny-admin-command:
    needs: parse-command
    if: needs.parse-command.outputs.command && contains('merge squash rebase', needs.parse-command.outputs.command) && needs.parse-command.outputs.is_admin != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Deny Admin Command
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = JSON.stringify("${{ needs.parse-command.outputs.commenter }}");
            const command = JSON.stringify("${{ needs.parse-command.outputs.command }}");
            const pr_number = JSON.stringify("${{ needs.parse-command.outputs.pr_number }}");
            const body = `‚õî @${JSON.parse(commenter)}, you do not have permission to run the \`/${JSON.parse(command)}\` command. This command is restricted to administrators.`
            await github.rest.issues.createComment({ ...context.repo, issue_number: JSON.parse(pr_number), body });

  # Job: Handle /release command
  handle-release:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'release'
    runs-on: ubuntu-latest
    outputs:
      success: ${{ steps.comment_result.outputs.success }}
    steps:
      - name: Validate /release argument and base branch
        id: validate
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            try {
              const validArgs = ['patch', 'minor', 'major'];
              const message = "${{ needs.parse-command.outputs.message }}".trim();
              const baseBranch = "${{ needs.parse-command.outputs.base_branch }}";
              const commenter = "${{ needs.parse-command.outputs.commenter }}";
              const prNumber = parseInt("${{ needs.parse-command.outputs.pr_number }}", 10);

              if (baseBranch !== 'develop') {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `@${commenter} ‚ö†Ô∏è The \`/release\` command only works on PRs targeting the \`develop\` branch. This PR targets \`${baseBranch}\`.`
                });
                return { valid: false };
              }
              if (!validArgs.includes(message)) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `@${commenter} ‚ö†Ô∏è Invalid release type \`${message}\`. Please use one of: \`patch\`, \`minor\`, or \`major\`.`
                });
                return { valid: false };
              }
              return { valid: true, releaseType: message };
            } catch (error) {
              console.error(error);
              return { valid: false, error: error.message };
            }

      - name: Abort if validation failed
        if: steps.validate.outputs.valid != 'true'
        run: echo "Validation failed, skipping release steps."

      - name: Checkout develop branch
        if: steps.validate.outputs.valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: '${{ secrets.APPROVER_TOKEN }}'

      - name: Fetch all tags
        if: steps.validate.outputs.valid == 'true'
        run: git fetch --tags

      - name: Calculate next version tag
        if: steps.validate.outputs.valid == 'true'
        id: version
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            try {
              function parseTag(tag) {
                const regex = /^v(\d+)\.(\d+)\.(\d+)(?:-beta\.(\d+))?$/;
                const m = regex.exec(tag);
                if (!m) return null;
                return {
                  major: parseInt(m[1], 10),
                  minor: parseInt(m[2], 10),
                  patch: parseInt(m[3], 10),
                  beta: m[4] ? parseInt(m[4], 10) : null,
                  original: tag
                };
              }

              let page = 1;
              let tags = [];
              while (true) {
                const { data } = await github.rest.git.listMatchingRefs({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'tags',
                  per_page: 100,
                  page
                });
                if (data.length === 0) break;
                tags = tags.concat(data.map(t => t.ref.replace('refs/tags/', '')));
                page++;
              }

              const semverTags = tags.map(parseTag).filter(x => x !== null);

              const stableTags = semverTags.filter(t => t.beta === null);
              stableTags.sort((a,b) =>
                a.major !== b.major ? b.major - a.major :
                a.minor !== b.minor ? b.minor - a.minor :
                b.patch - a.patch
              );
              const latestStable = stableTags[0] || {major:0,minor:0,patch:0};

              const betaTagsForLatest = semverTags.filter(t =>
                t.major === latestStable.major &&
                t.minor === latestStable.minor &&
                t.patch === latestStable.patch &&
                t.beta !== null
              );

              betaTagsForLatest.sort((a,b) => b.beta - a.beta);
              const latestBeta = betaTagsForLatest[0];

              const releaseType = "${{ steps.validate.outputs.releaseType }}";

              let newMajor = latestStable.major;
              let newMinor = latestStable.minor;
              let newPatch = latestStable.patch;

              if (releaseType === 'major') {
                newMajor++;
                newMinor = 0;
                newPatch = 0;
              } else if (releaseType === 'minor') {
                newMinor++;
                newPatch = 0;
              } else if (releaseType === 'patch') {
                newPatch++;
              }

              let newBetaNumber = 1;
              if (latestBeta &&
                latestBeta.major === newMajor &&
                latestBeta.minor === newMinor &&
                latestBeta.patch === newPatch) {
                newBetaNumber = latestBeta.beta + 1;
              }

              const newTag = `v${newMajor}.${newMinor}.${newPatch}-beta.${newBetaNumber}`;

              return { newTag };
            } catch (error) {
              console.error(error);
              return { newTag: null, error: error.message };
            }

      - name: Fail if version calculation failed
        if: steps.version.outputs.newTag == 'null' || steps.version.outputs.newTag == ''
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            const commenter = "${{ needs.parse-command.outputs.commenter }}";
            const prNumber = parseInt("${{ needs.parse-command.outputs.pr_number }}", 10);
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `@${commenter} ‚ùå Oops! I couldn't calculate the next version tag due to an internal error. Please check the workflow logs or try again later.`
            });
        continue-on-error: true

      - name: Create and push new tag
        if: steps.validate.outputs.valid == 'true' && steps.version.outputs.newTag != '' && steps.version.outputs.newTag != 'null'
        run: |
          git config user.name "PriestyBot"
          git config user.email "priestybot@example.com"
          git tag ${{ steps.version.outputs.newTag }}
          git push origin ${{ steps.version.outputs.newTag }}
        shell: bash
        continue-on-error: false

      - name: Comment new pre-release tag with deploy instructions
        id: comment_result
        if: steps.validate.outputs.valid == 'true' && steps.version.outputs.newTag != '' && steps.version.outputs.newTag != 'null'
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            try {
              const commenter = "${{ needs.parse-command.outputs.commenter }}";
              const prNumber = parseInt("${{ needs.parse-command.outputs.pr_number }}", 10);
              const newTag = "${{ steps.version.outputs.newTag }}";
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `@${commenter} üöÄ Your beta pre-release tag **${newTag}** has been created and pushed to the \`develop\` branch.\n\n` +
                      `You can deploy this pre-release build to the Beta environment using the \`deploy-beta\` workflow, selecting the **Beta** environment and specifying this tag as the release tag.\n\n` +
                      `**Note:** This is a pre-release build for testing on Beta only. It is not intended for Production.\n\n` +
                      `Happy testing! üéâ`
              });
              return { success: 'true' };
            } catch (error) {
              console.error(error);
              return { success: 'false' };
            }
  # Job: Handle /tag command for production releases (create & push tag)
  handle-tag:
    needs: parse-command
    if: needs.parse-command.outputs.command == 'tag'
    runs-on: ubuntu-latest
    outputs:
      success: ${{ steps.comment_result.outputs.success }}
    steps:
      - name: Validate /tag argument and base branch
        id: validate
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            try {
              const tag = "${{ needs.parse-command.outputs.message }}".trim();
              const baseBranch = "${{ needs.parse-command.outputs.base_branch }}";
              const commenter = "${{ needs.parse-command.outputs.commenter }}";
              const prNumber = parseInt("${{ needs.parse-command.outputs.pr_number }}", 10);

              # Check branch is main
              if (baseBranch !== 'main') {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `@${commenter} ‚ö†Ô∏è The \`/tag\` command only works on PRs targeting the \`main\` branch. This PR targets \`${baseBranch}\`.`
                });
                return { valid: false };
              }

              # Simple semver tag validation: vX.Y.Z
              const semverRegex = /^v\d+\.\d+\.\d+$/;
              if (!semverRegex.test(tag)) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `@${commenter} ‚ö†Ô∏è Invalid tag format \`${tag}\`. Please provide a semantic version tag like \`v1.2.3\`.`
                });
                return { valid: false };
              }

              # Check if tag already exists
              try {
                await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tag}`
                });
                # If above does not throw, tag exists
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `@${commenter} ‚ö†Ô∏è Tag \`${tag}\` already exists on the repository. Please choose a new version number.`
                });
                return { valid: false };
              } catch (error) {
                if (error.status !== 404) {
                  throw error; # unexpected error
                }
                # Tag does not exist, all good
              }

              return { valid: true, tag };
            } catch (error) {
              console.error(error);
              return { valid: false, error: error.message };
            }

      - name: Abort if validation failed
        if: steps.validate.outputs.valid != 'true'
        run: echo "Validation failed, skipping tag creation."

      - name: Checkout main branch
        if: steps.validate.outputs.valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: '${{ secrets.APPROVER_TOKEN }}'

      - name: Create and push new production tag
        if: steps.validate.outputs.valid == 'true'
        run: |
          git config user.name "PriestyBot"
          git config user.email "priestybot@example.com"
          git tag ${{ steps.validate.outputs.tag }}
          git push origin ${{ steps.validate.outputs.tag }}
        shell: bash

      - name: Comment tag creation success with instructions
        id: comment_result
        if: steps.validate.outputs.valid == 'true'
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.APPROVER_TOKEN }}'
          script: |
            try {
              const commenter = "${{ needs.parse-command.outputs.commenter }}";
              const prNumber = parseInt("${{ needs.parse-command.outputs.pr_number }}", 10);
              const tag = "${{ steps.validate.outputs.tag }}";
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `@${commenter} üöÄ Production release tag **${tag}** has been created and pushed to the \`main\` branch.\n\n` +
                      `This will trigger the production build and deployment workflows.\n\n` +
                      `Please monitor the workflow runs to confirm deployment success.\n\n` +
                      `Thank you for releasing! üéâ`
              });
              return { success: 'true' };
            } catch (error) {
              console.error(error);
              return { success: 'false' };
            }
