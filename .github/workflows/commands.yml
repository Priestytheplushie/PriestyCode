# .github/workflows/priestybot-commands.yml
# A complete rewrite of the PriestyBot command handler for better maintainability and robustness.

name: PriestyBot Commands

on:
  issue_comment:
    types: [created]

permissions:
  # Required for checking out code, creating reviews, commenting, and merging.
  contents: write
  pull-requests: write

jobs:
  command-handler:
    # Only run this workflow for comments on active Pull Requests and if the commenter is not the bot itself.
    if: github.event.issue.pull_request && github.actor != 'PriestyBot'
    runs-on: ubuntu-latest

    steps:
      # STEP 1: PARSE THE COMMAND FROM THE COMMENT
      # This step identifies the command and arguments, making subsequent steps much cleaner.
      - name: Parse Command
        id: parser
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.comment.body.trim();
            if (!body.startsWith('/')) {
              console.log("Comment is not a command.");
              return;
            }
            const args = body.split(/\s+/);
            const command = args[0].substring(1);
            const message = args.slice(1).join(' ');

            # Add 'resolve' to the list of valid commands
            const validCommands = ['help', 'approve', 'request-changes', 'comment', 'format', 'lint', 'merge', 'squash', 'rebase', 'resolve'];
            
            if (!validCommands.includes(command)) {
              console.log(`Unknown command: ${command}`);
              core.setOutput('command', 'unknown');
              return;
            }

            core.setOutput('command', command);
            core.setOutput('message', message);
            console.log(`Command: ${command}, Message: ${message}`);

      # STEP 2: CHECK ADMIN STATUS (if needed for certain commands, like merge/squash/rebase)
      - name: Check Admin Status
        id: check_admin
        if: steps.parser.outputs.command != 'unknown' && contains('merge squash rebase', steps.parser.outputs.command)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const { data: permissions } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: context.payload.comment.user.login,
            });
            const isAdmin = permissions.permission === 'admin' || permissions.permission === 'maintain';
            core.setOutput('is_admin', isAdmin ? 'true' : 'false');
            console.log(`User ${context.payload.comment.user.login} is admin: ${isAdmin}`);

      # STEP 3: EXECUTE COMMANDS
      # --- COMMAND: /resolve ---
      - name: Handle /resolve Command (Prepare Environment)
        id: handle_resolve_env
        if: steps.parser.outputs.command == 'resolve'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }} # Use APPROVER_TOKEN for permissions
          script: |
            const pr_number = context.issue.number;
            const { data: pull_request } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
            });

            # Set environment variables for the next step (running the Python script)
            core.exportVariable('PR_NUMBER', pr_number);
            core.exportVariable('BASE_BRANCH', pull_request.base.ref);
            core.exportVariable('HEAD_BRANCH', pull_request.head.ref);
            core.exportVariable('REPO_NAME', context.repo.owner + '/' + context.repo.repo);
            core.exportVariable('BOT_USERNAME', 'PriestyBot'); # Ensure this matches your bot's username
            core.exportVariable('BOT_REVIEW_TAG', '<!-- PriestyBotMergeConflictBot -->');
            core.exportVariable('GH_TOKEN', process.env.APPROVER_TOKEN); # Pass the PAT

      - name: Checkout Code (for /resolve command)
        if: steps.parser.outputs.command == 'resolve'
        uses: actions/checkout@v4 # Checkout to get the script
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0 # Needed for git operations in the script
          token: ${{ secrets.APPROVER_TOKEN }} # Use APPROVER_TOKEN for checkout

      - name: Setup Python (for /resolve command)
        if: steps.parser.outputs.command == 'resolve'
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Dependencies (for /resolve command)
        if: steps.parser.outputs.command == 'resolve'
        run: |
          python -m pip install --upgrade pip
          pip install PyGithub

      - name: Execute Conflict Resolver Script
        id: run_resolver_script # Add an ID to capture output
        if: steps.parser.outputs.command == 'resolve'
        # IMPORTANT: Your Python script needs to output a status like this:
        # print(f"::set-output name=status::no_conflicts") or
        # print(f"::set-output name=status::conflicts_posted") or
        # print(f"::set-output name=status::error")
        # For this YAML to correctly post human-like messages.
        run: |
          python ${{ github.workspace }}/.github/scripts/conflict_resolver.py
          # If the python script completes without error, assume success by default
          # This default output will be overridden if the python script explicitly sets 'status'
          echo "::set-output name=status::success" 
        continue-on-error: true # Allow subsequent steps to run even if script fails

      - name: Post Success Message for /resolve (Conflicts Handled)
        if: steps.parser.outputs.command == 'resolve' && steps.run_resolver_script.outcome == 'success' && steps.run_resolver_script.outputs.status == 'conflicts_posted'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `@${commenter} ‚úÖ PriestyBot has posted a new review with merge conflict suggestions. Please check the 'Files changed' tab!`
            });

      - name: Post Message for /resolve (No Conflicts Found)
        if: steps.parser.outputs.command == 'resolve' && steps.run_resolver_script.outcome == 'success' && steps.run_resolver_script.outputs.status == 'no_conflicts'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `@${commenter} ‚ú® Good news! PriestyBot checked, and there are currently no merge conflicts detected on this Pull Request. You're all clear!`
            });

      - name: Post Error Message for /resolve Command Failure
        if: steps.parser.outputs.command == 'resolve' && steps.run_resolver_script.outcome == 'failure' || (steps.parser.outputs.command == 'resolve' && steps.run_resolver_script.outputs.status == 'error')
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `@${commenter} ‚ùå Oops! PriestyBot encountered an issue while trying to resolve merge conflicts. Please check the workflow run logs for details, or try resolving manually. My apologies!`
            });

      # --- Other Commands (example) ---
      - name: Handle /approve Command
        if: steps.parser.outputs.command == 'approve'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: 'APPROVE',
              body: 'PriestyBot approves this PR! ‚úÖ'
            });

      - name: Handle /request-changes Command
        if: steps.parser.outputs.command == 'request-changes'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: 'REQUEST_CHANGES',
              body: 'PriestyBot requests changes on this PR. Please address my concerns. üìù'
            });

      - name: Handle /comment Command
        if: steps.parser.outputs.command == 'comment'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const message = `${{ steps.parser.outputs.message }}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `PriestyBot says: ${message}`
            });

      - name: Handle /help Command
        if: steps.parser.outputs.command == 'help'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            const helpMessage = `
            @${commenter} ü§ñ Here are the commands you can use with PriestyBot:

            * \` /help \`: Displays this help message.
            * \` /approve \`: Approves the Pull Request.
            * \` /request-changes \`: Requests changes on the Pull Request.
            * \` /comment <your message> \`: Leaves a general comment on the Pull Request.
            * \` /format \`: (If configured) Runs code formatting tools.
            * \` /lint \`: (If configured) Runs code linting tools.
            * \` /resolve \`: **(NEW!)** Triggers PriestyBot to check for and suggest resolutions for merge conflicts on this PR.
            * \` /merge \`: (Admin only) Merges the Pull Request (fast-forward).
            * \` /squash \`: (Admin only) Squashes and merges the Pull Request.
            * \` /rebase \`: (Admin only) Rebases and merges the Pull Request.

            Please ensure you have the necessary permissions for each command.
            `;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: helpMessage
            });

      # --- Other commands like /format, /lint, /merge, /squash, /rebase would go here ---
      # CONCEPTUAL: Example of a merge/squash command that might fail due to conflicts
      - name: Handle /merge or /squash Command (Conceptual)
        id: merge_squash_attempt
        if: contains(fromJSON('["merge", "squash"]'), steps.parser.outputs.command) && steps.check_admin.outputs.is_admin == 'true'
        run: |
          echo "Attempting conceptual merge/squash..."
          # In a real scenario, this would involve Git commands like:
          # git checkout ${{ github.base_ref }}
          # git pull origin ${{ github.base_ref }}
          # git merge --squash ${{ github.event.pull_request.head.ref }} # for squash
          # git merge ${{ github.event.pull_request.head.ref }} # for merge
          # Then check for conflicts or success/failure
          # For now, we'll simulate a failure for testing the error message.
          # To simulate success, change 'exit 1' to 'exit 0'
          exit 1 # Simulate failure for demonstration
        continue-on-error: true # Allow subsequent steps to run

      - name: Recommend /resolve if Merge/Squash Failed
        if: contains(fromJSON('["merge", "squash"]'), steps.parser.outputs.command) && steps.merge_squash_attempt.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            const command = "${{ steps.parser.outputs.command }}";
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `@${commenter} ‚ö†Ô∏è The \`/${command}\` command failed, likely due to merge conflicts. Please use the \`/resolve\` command to get suggestions for fixing the conflicts, or resolve them manually.`
            });

      # --- POST-EXECUTION AND ERROR HANDLERS ---
      - name: Post Command Status
        if: always() && steps.parser.outputs.command && steps.parser.outputs.command != 'unknown'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          # Pass job_status as an explicit input
          script: |
            const command = "${{ steps.parser.outputs.command }}";
            # Safely get the job status from the GitHub Actions context
            const conclusion = process.env.JOB_STATUS; # Access via environment variable
            const emoji = conclusion === 'success' ? '‚úÖ' : '‚ùå';
            const commenter = context.payload.comment.user.login;
            const body = `@${commenter} ${emoji} Command \`/${command}\` finished with status: **${conclusion}**.`;
            await github.rest.issues.createComment({ ...context.repo, issue_number: context.issue.number, body });
        env:
          JOB_STATUS: ${{ job.status }} # Set job.status as an environment variable

      - name: Deny Admin Command
        if: steps.parser.outputs.command && contains('merge squash rebase', steps.parser.outputs.command) && steps.check_admin.outputs.is_admin != 'true'
        run: echo "‚õî User is not an admin and cannot run merge commands." && exit 1

      - name: Handle Unknown Command
        if: steps.parser.outputs.command == 'unknown'
        run: echo "ü§î Unknown command. Please use /help for a list of available commands." && exit 0
