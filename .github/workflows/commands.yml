# .github/workflows/priestybot-commands.yml
# A complete rewrite of the PriestyBot command handler for better maintainability and robustness.

name: PriestyBot Commands

on:
  issue_comment:
    types: [created]

permissions:
  # Required for checking out code, creating reviews, commenting, and merging.
  contents: write
  pull-requests: write

jobs:
  command-handler:
    # Only run this workflow for comments on active Pull Requests and if the commenter is not the bot itself.
    if: github.event.issue.pull_request && github.actor != 'PriestyBot'
    runs-on: ubuntu-latest

    steps:
      # STEP 1: PARSE THE COMMAND FROM THE COMMENT
      # This step identifies the command and arguments, making subsequent steps much cleaner.
      - name: Parse Command
        id: parser
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.comment.body.trim();
            if (!body.startsWith('/')) {
              console.log("Comment is not a command.");
              return;
            }
            const args = body.split(/\s+/);
            const command = args[0].substring(1);
            const message = args.slice(1).join(' ');

            const validCommands = ['help', 'approve', 'request-changes', 'comment', 'format', 'lint', 'merge', 'squash', 'rebase'];
            if (validCommands.includes(command)) {
              core.setOutput('command', command);
              core.setOutput('message', message);
            } else {
              core.setOutput('command', 'unknown');
            }

      # STEP 2: CHECK IF THE COMMENTER HAS ADMIN PRIVILEGES
      # This runs only if a command was found that might require admin rights.
      - name: Check Admin Privileges
        id: check_admin
        if: steps.parser.outputs.command && contains('merge squash rebase help', steps.parser.outputs.command)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const commenter = context.payload.comment.user.login;
            const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({ owner, repo, username: commenter });
            const isAdmin = ['admin', 'maintain'].includes(perm.permission);
            core.setOutput('is_admin', isAdmin);

      # STEP 2.5: Acknowledge Command
      - name: Acknowledge Command
        if: steps.parser.outputs.command != 'unknown'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            const command = "${{ steps.parser.outputs.command }}";
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: `@${commenter} I received your \`/${command}\` command. Processing... ‚è≥`
            });

      # STEP 3: SETUP TOOLS IF NEEDED
      # Checkout the code and install Python tools only for commands that require them.
      - name: Checkout PR Branch
        if: contains('format lint', steps.parser.outputs.command)
        uses: actions/checkout@v4
        with:
          # Check out the head of the PR, not the merge commit
          ref: ${{ github.event.pull_request.head.ref }}
          # Use a token that can push back for formatting changes
          token: ${{ secrets.APPROVER_TOKEN }}

      - name: Setup Python & Tools
        if: contains('format lint', steps.parser.outputs.command)
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      - run: pip install black isort flake8 mypy
        if: contains('format lint', steps.parser.outputs.command)
      # Removed reviewdog setup as we are no longer using it for PR reviews.

      # --- COMMAND HANDLERS ---

      - name: Handle /help
        if: steps.parser.outputs.command == 'help'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const isAdmin = ${{ steps.check_admin.outputs.is_admin || 'false' }};
            let helpMessage = `### ‚ú® PriestyBot General Commands\n\n`;
            helpMessage += "- `/help`: Show this help message.\n";
            helpMessage += "- `/approve [message]`: Approve the PR.\n";
            helpMessage += "- `/request-changes <reason>`: Request changes with a required reason.\n";
            helpMessage += "- `/comment <message>`: Leave a general comment.\n";
            helpMessage += "- `/format`: Auto-format Python code with **black** and **isort**.\n";
            helpMessage += "- `/lint`: Run **flake8**, **isort**, and **mypy** and report issues in a PR review.\n";

            if (isAdmin) {
              helpMessage += `\n### üîê Admin Commands\n\n`;
              helpMessage += "- `/merge [message]`: Merge the PR.\n";
              helpMessage += "- `/squash [message]`: Squash and merge the PR.\n";
              helpMessage += "- `/rebase`: Rebase and merge the PR.\n";
            }

            await github.rest.issues.createComment({
              ...context.repo, issue_number: context.issue.number, body: helpMessage
            });

      - name: Handle /approve, /request-changes, /comment
        if: contains('approve request-changes comment', steps.parser.outputs.command)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const command = "${{ steps.parser.outputs.command }}";
            const message = "${{ steps.parser.outputs.message }}";
            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;

            if ((command === 'request-changes' || command === 'comment') && !message) {
              await github.rest.issues.createComment({ owner, repo, issue_number,
                body: `‚ö†Ô∏è A message is required for the \`/${command}\` command.`
              });
              core.setFailed('Missing message for command.');
              return;
            }

            switch (command) {
              case 'approve':
                await github.rest.pulls.createReview({ owner, repo, pull_number: issue_number, event: 'APPROVE', body: message || 'PR approved! üëç' });
                break;
              case 'request-changes':
                await github.rest.pulls.createReview({ owner, repo, pull_number: issue_number, event: 'REQUEST_CHANGES', body: message });
                break;
              case 'comment':
                await github.rest.issues.createComment({ owner, repo, issue_number, body: message });
                break;
            }

      - name: Handle /format
        if: steps.parser.outputs.command == 'format'
        id: format
        run: |
          isort .
          black .
          # Set output 'changed' to true if there are any unstaged changes.
          git diff --quiet || echo "changed=true" >> $GITHUB_OUTPUT

      - name: Commit Formatting Changes
        if: steps.format.outputs.changed == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(bot): Auto-format Python code"
          commit_user_name: PriestyBot
          commit_user_email: priestybot@users.noreply.github.com
          token: ${{ secrets.APPROVER_TOKEN }}

      - name: Handle /lint - Initial Progress Comment
        if: steps.parser.outputs.command == 'lint'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: `Starting linting checks... This might take a moment. ‚è≥`
            });

      - name: Handle /lint - Run Linters and Capture Output
        if: steps.parser.outputs.command == 'lint'
        id: run_linters # Added an ID to this step to access its outputs
        run: |
          echo "Linting output will be saved to lint_output.txt"
          # Run linters and save output to a file, also print to stdout
          {
            echo "--- flake8 output ---"
            flake8 . || true
            echo ""
            echo "--- mypy output ---"
            mypy . --ignore-missing-imports || true
            # If you want to include isort in linting, uncomment the line below:
            # echo ""
            # echo "--- isort output ---"
            # isort --check-only . || true
          } > lint_output.txt 2>&1

          # Check if the file is empty or contains only whitespace
          if [ -s lint_output.txt ]; then
            echo "has_lint_output=true" >> $GITHUB_OUTPUT
          else
            echo "has_lint_output=false" >> $GITHUB_OUTPUT
          fi

      - name: Post Linting Summary
        if: steps.parser.outputs.command == 'lint' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;
            const jobStatus = process.env.JOB_STATUS; // Get the overall job status
            // Access output from the previous step
            const hasLintOutput = "${{ steps.run_linters.outputs.has_lint_output }}" === "true";

            let message = '';

            if (jobStatus === 'success' && !hasLintOutput) {
              message = `‚úÖ Linting checks completed successfully! No issues found.`;
            } else if (hasLintOutput) {
              message = `‚ö†Ô∏è Linting checks completed with some issues. Please see details below:`;
              const lintOutput = `\`\`\`\n${require('fs').readFileSync('lint_output.txt', 'utf8')}\n\`\`\``;
              message += `\n<details><summary>Click to view Linting Output</summary>\n\n${lintOutput}\n</details>`;
            } else {
              message = `‚ùå Linting checks failed to complete. Please check the workflow run for details.`;
            }

            await github.rest.issues.createComment({
              owner, repo, issue_number, body: message
            });
        env:
          JOB_STATUS: ${{ job.status }} # Pass job status to the script

      - name: Handle Merge Commands (/merge, /squash, /rebase)
        if: steps.check_admin.outputs.is_admin == 'true' && contains('merge squash rebase', steps.parser.outputs.command)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          script: |
            const merge_method = "${{ steps.parser.outputs.command }}";
            const commit_title = "${{ steps.parser.outputs.message }}" || `Merged via /${merge_method} command`;
            const { owner, repo } = context.repo;
            const pull_number = context.issue.number;

            try {
              await github.rest.pulls.merge({ owner, repo, pull_number, merge_method, commit_title });
            } catch (e) {
              await github.rest.issues.createComment({ owner, repo, issue_number: pull_number,
                body: `‚ùå **Merge failed!** The API returned the following error:\n\`\`\`\n${e.message}\n\`\`\``
              });
              core.setFailed(e.message);
            }

      # --- FINALIZATION AND ERROR HANDLERS ---
      - name: Post Command Status
        if: always() && steps.parser.outputs.command && steps.parser.outputs.command != 'unknown'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.APPROVER_TOKEN }}
          # Pass job_status as an explicit input
          script: |
            const command = "${{ steps.parser.outputs.command }}";
            // Safely get the job status from the GitHub Actions context
            const conclusion = process.env.JOB_STATUS; // Access via environment variable
            const emoji = conclusion === 'success' ? '‚úÖ' : '‚ùå';
            const commenter = context.payload.comment.user.login;
            const body = `@${commenter} ${emoji} Command \`/${command}\` finished with status: **${conclusion}**.`;
            await github.rest.issues.createComment({ ...context.repo, issue_number: context.issue.number, body });
        env:
          JOB_STATUS: ${{ job.status }} # Set job.status as an environment variable

      - name: Deny Admin Command
        if: steps.parser.outputs.command && contains('merge squash rebase', steps.parser.outputs.command) && steps.check_admin.outputs.is_admin != 'true'
        run: echo "‚õî User is not an admin and cannot run merge commands." && exit 1

      - name: Handle Unknown Command
        if: steps.parser.outputs.command == 'unknown'
        run: echo "ü§î Unknown command. Use '/help' to see available commands." && exit 1